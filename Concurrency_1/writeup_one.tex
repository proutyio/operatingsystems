\documentclass[letterpaper,10pt]{article}

% Package imports
\usepackage{graphicx}                                        
\usepackage{amssymb}                                         
\usepackage{amsmath}                                         
\usepackage{amsthm}                                          

\usepackage{alltt}                                           
\usepackage{float}
\usepackage{color}
\usepackage{url}

\usepackage{hyperref}
\usepackage{titling}
\usepackage{makecell}

\usepackage{balance}
\usepackage[TABBOTCAP, tight]{subfigure}
\usepackage{enumitem}
%\usepackage{pstricks, pst-node}

\usepackage{geometry}
\geometry{textheight=8.5in, textwidth=6in}

%random comment

\newcommand{\cred}[1]{{\color{red}#1}}
\newcommand{\cblue}[1]{{\color{blue}#1}}

% Format settings
\setlength\parindent{0pt}

%\def\name{Kyle Prouty and Nathaniel Whitlock}

%pull in the necessary preamble matter for pygments output
%\input{pygments.tex}

%% The following metadata will show up in the PDF properties
% \hypersetup{
%   colorlinks = true,
%   urlcolor = black,
%   pdfauthor = {\name},
%   pdfkeywords = {cs311 ``operating systems'' files filesystem I/O},
%   pdftitle = {CS 311 Project 1: UNIX File I/O},
%   pdfsubject = {CS 311 Project 1},
%   pdfpagemode = UseNone
% }

\title{\bf CS 444: Project One\\\Large{Getting Acquainted}}

\author{Kyle Prouty \&\\Nathaniel Whitlock\\OSU Fall 2017}

\begin{document}
\begin{titlingpage}
    \maketitle   
    \vspace{1in}
    \begin{abstract}
      \noindent The following document contains a discussion of our purposed concurrency solution along with answers to the questions from the assignment requirements. Additionally, there is a ordered listing of the commands we used during the linux-yocto kernel build. As requested, there is also a breakdown of the qemu command which we were supplied. All steps required for extra credit on the concurrency assignment have been successfully implemented.
    \end{abstract}
\end{titlingpage}

\section{Concurrency Solution} 
%% Should we talk about the pthread object, mutex, and cond_t initialization
Our program begins by checking if the RdRand instruction was supported on the host system. If it is supported, a flag variable is set to enable  the use of assembly calls to RdRand. If RdRand is not supported, then the flag will remain unset and the supplied Merseene Twister library (\textit{mt19973ar.c }) is then utilized to generate the random values used throughout the programs execution. A display message indicates which method will be used to stdout. \\

Using the pthread\_create() function, multiple producer and consumer threads are then generated by means of a for loop. A constant used to indicated the desired number of threads, the same number of producers and consumers are created and targeted at their associated functions. After the threads are created we then call join on the consumer threads in order to move the execution from the calling thread to a consumer thread. \\

All the threads are competing for the same mutex lock, so as soon as the execution moves to the consumer threads, the first one to lock gets to do the work. Once a consumer thread locks, it then checks that if the buffer is empty before trying to add to it. If the buffer is full, the program blocks using a conditional wait variable and then unlocks the mutex. When the while loop blocks on the conditional variable it causes the current thread to sleep and allow another thread to grab the lock. If the buffer was not full after the consumer thread locked then the consumer will sleep for a random amount of time to show the work used to consume, then print to the console the value that was consumed. After the work has been done to consume the consumer thread unblocks any thread that is being blocked on the producer conditional variable and then unlocks the mutex so that another thread can grab the lock. \\

Producers and consumer threads do basically the same thing, they try to lock, if they get the lock then they check the buffer. If the buffer is full/empty they block on a conditional variable and then unlock the mutex so that another thread that is not blocked can grab the mutex. When the buffer is not full/empty, producers and consumers then do the work that they need to either consumer or produce and then unblock any threads block by the opposite conditional variable, then unlock the mutex so that another thread can grab the mutex and start the process over. Both the consumer and producer threads are sitting in infinite loops so that any spawned threads will continue running until the users explicitly quits the program.

\subsection{Purpose}
% What do you think the main point of this assignment is?
This main point of this assignment is to exercise the use of a mutex to manage a multi-process environment, in order to understand how many different threads can share the same variables without causing deadlocks or race conditions. The producer-consumer problem not only resembles multi-threaded execution, but also of the client-host relationship in regards to networking traffic. The organized interaction between producers, consumers and the buffer structure is important so that neither entity destructively interfere with the other. It is essential to protect shared values when many different threads are attempting to access the same shared variables. With a working solution to producer-consumer problem, execution time can be split among threads, leading to shared workload that can be completed faster. There is some added overhead created by the need to ensure the consumers only interact with the storage buffer at appropriate times, but the benefit is most often times greater than the cost.

\subsection{Design Decisions}
% How did you personally approach the problem? Design decisions, algorithms, etc.
I started this assignment by reading through the requirements provided and then white boarding my initial impressions of how I thought the code might work. After that I went and looked up the pthread library to refresh my understanding. While looking through the library I found a few functions that seemed to fit this project perfectly, pthread\_cond\_wait and pthread\_cond\_broadcast. Once I discovered the proper tools, I then went back to my white board and wrote out the pseudo code for the program. I immediately took a break after my first go at pseudo code so I could go back to thinking about the problem and then come back and modify my pseudo code. When I felt confident that I had gone as far as a could with pseudo code, I then started writing the actual C code. 

\subsection{Testing}
% How did you ensure your solution was correct? Testing details?
We ensured that our solution was correct by testing different parts of the program. First we tested that we did not encounter any deadlocks or race conditions by printing out the values to the console at every step of the execution to see that the program was flowing correctly and it did not hang due to deadlocks. Next we tested the bounds by letting the program run to see that the buffer could fill to max without going over its bounds and that it could empty to its min without going over the bounds of the array. Another area that we tested was to make sure that our different number generators were producing numbers in the correct range. It took a lot of guess and checking with both RdRand and the twister to get the proper ranges for the two different algorithms. The last thing we checked was to make sure that our program meet all the requirements listed on the assignment, making sure we did not overlook anything.

\subsection{Learnings and Reinforcements}
Through the course of this assignment we learned or reinforced the following:
\begin{itemize}
  \item Use of pthreads C library
    \begin{itemize}
      \item Learning how to utilize pthread conditional variables
        \item Understanding how one mutex can control many threads that have shared variables
    \end{itemize}
    \item Configuration of functional makefile:
    \begin{itemize}
      \item Utilizing targets to specify execution pathway
        \item Dynamically running target blocks by using variable values 
    \end{itemize}
    \item Familiarization with using \LaTeX{} for word processing:
    \begin{itemize}
      \item Learning useful commonly used format functions
        \item Documenting useful packages
        \item Understanding the DVI $\rightarrow$ PS $\rightarrow$ PDF pipeline and why it is important
    \end{itemize}
\end{itemize}

\section{Command Log}
\subsection{Kernel assignment}
\begin{itemize}
  \item Clone git repo: 
    \begin{itemize}
      \item git clone git://git.yoctoproject.org/linux-yocto-3.19
    \end{itemize}
    \item Checkout v3.19.2 (From cloned repo): 
    \begin{itemize}
      \item git checkout tags/v3.19.2
    \end{itemize}
    \item Copy configuration file: 
    \begin{itemize}
      \item cp /scratch/files/config-3.19.2-yocto-standard linux-yocto-3.19/.config
    \end{itemize}
    \item Copy image and core files: 
    \begin{itemize}
      \item cp /scratch/files/bzImage-qemux86.bin /scratch/fall2017/18/
        \item cp /scratch/files/core-image-lsb-sdk-qemux86.ext4  /scratch/fall2017/18/
    \end{itemize}
    \item Source environment variables (BASH):
        \begin{itemize}
          \item source /scratch/files/environment-setup-i586-poky-linux
        \end{itemize}
        \item Kernel build: 
        \begin{itemize}
          \item make -j4 all
        \end{itemize}
        \item Run VM (From home): 
        \begin{itemize}
          \item qemu-system-i386 -gdb tcp::5518 -S -nographic -kernel bzImage-qemux86.bin -drive file=core-image-lsb-sdk-qemux86.ext4,if=virtio -enable-kvm -net none -usb -localtime --no-reboot --append ``root=/dev/vda rw console=ttyS0 debug''
         \end{itemize}
    \item Using GDB to continue VM:
    \begin{itemize}
      \item Establish secondary ssh connection to OSII server and login
        \item Launch gdb:
        \begin{itemize}
          \item target remote :5518
            \item continue
        \end{itemize}
    \item Logging into VM (From primary ssh connection):
    \begin{itemize}
      \item username: root
        \item password: (blank)
    \end{itemize}
    \end{itemize}
\end{itemize}

% qemu commands broken down
\subsection{Qemu-system-i386 Command Breakdown}
\begin{itemize}
  \item -gdb: Wait for gdb connection, optionally pass argument for target host
    \item tcp: Specify the transmission control protocol port number
    \item -nographic: Disable graphical output and redirect serial I/Os to console
    \item -kernel: Specify the kernel image to use, use 'bzImage'
    \item -drive: Specify the file system, use file argument as a drive image
    \item if=virtio: Conditional check for virtual IO
    \item -enable-kvm: Enable kernel virutal machine full virtualization support
    \item -net none: Enables zero network devices
    \item -usb: Enable the usb driver
    \item -localtime: Define time format
    \item --no-reboot: Exit instead of rebooting
    \item --append ``root=/dev/vda rw console=ttyS0 debug'': Specify kernel command line
    \item -S: Freeze cpu at startup
\end{itemize}
\section{Version Control Log}

% Insert git change log
\input{changelog.tex}

\section{Work Log}
Each week since the class started, both of us have met directly after Operating Systems in the Valley Public Library. During these sessions we worked on the following items:
\begin{itemize}
  \item Kyle Prouty: 
    \begin{itemize}
          \item Week One:
          \begin{itemize}
              \item Created git repository
              \item Initial outlining of concurrency assignment
              \item Brainstorming and exploring libraries
              \item Finished outlining of concurrency assignment
              \item Initial C code implementation
              \item Bug fixes - One Consumer/Producer stable
              \item Finished normal credit parts of concurrency assignment
              \item Re-factor code to work with multiple consumers/producers
              \item Finished extra credit part of concurrency assignment
          \end{itemize}
          \item Week Two:
          \begin{itemize}
              \item Worked through kernel assignment
              \item Completed concurrency extra credit
              \item Prepared final write up for submission
          \end{itemize}
        \end{itemize}
    \item Nathaniel Whitlock:
    \begin{itemize}
      \item Week One:
        \begin{itemize}
          \item Began working on the kernel assignment
            \item Ran into issues getting the qemu command to work, provided command was incomplete
            \item Created outline for paper write-up
            \item Reviewed pthread library functions
        \end{itemize}
        \item Week Two:
        \begin{itemize}
          \item Completed kernel assignment and wrote up commands used
            \item Finished qemu command breakdown
            \item Discovered script to convert git commit log into a \LaTeX{} table
            \item Prepared final write up for submission
            \item Worked on modified makefile
        \end{itemize}
    \end{itemize}
\end{itemize}
\end{document}
